Ethan Fox and Ben Secor

Our overall strategy for PA4 was to approach the project in a modular way. We worked on generating test cases first, followed by a consistent implementation of the type checking rules, and then finally by each subsequent segment of output.To handle the class hierarchy, we implemented class inheritance and method overriding checking. We utilized a method_map, which was a hash map that mapped classes, to method names, to a tuple that contained the return type and arguments. This approach facilitated the type checking of static, self, and dynamic dispatch, as we could easily access the maps to determine where methods were inherited from and verify their arguments and types.

Similarly, we implemented a find_least_common_ancestor(type1, type2) method that returned the least common type along the inheritance map. If the types had nothing in common, the method returned Object (the base of all inheritance trees). This method was frequently used in type checking to determine if type1 was a subtype of type2. If type1 was a subtype of type2, the return value of find_least_common_ancestor(type1, type2) would be type2. This is because the least common ancestor checks the smallest ancestors first meaning the possibilities further down the tree are checked first.

For the three bad.cl files that were created in order to test negative cases and generate unique type checking errors, we tried to create simple files that produced these errors. For bad1.cl, we simply made a main() that compares a String to an Object, which produces a type checking error. The next negative test was in bad2.cl where we treated an Int as if it were a Bool by saying "If int." In a language like C this would just evaluate to True if the int was greater than zero, but in Cool it is a type error to have a conditional with type Int. For our last negative test case, bad3.cl, we went for a more complicated error. This error is created in our test file by having a class B redefine the method abort() and change its return type from Object to SELF_TYPE. This is done by making classes A and B that both define abort() differently to produce a type checking error.

For our good.cl test case we tried to test a wide variety of different Cool features without causing type errors. We included typical uses of classes and types such as methods using Ints and returning Bools. In addition we test inheritance by creating classes Main and Test that inherit from IO. This inheritance is put to the test by using out_string in the Test class which is inherited from IO. One of the more rigorous type checking scenarios that we also included in the good.cl test file is a dynamic dispatch example. A test object is made in main() and many method calls are made on the object which pass without throwing any type checking errors, including a dynamic and a polymorphic dispatch.